{"version":3,"file":"injected_document_start.js","sourceRoot":"","sources":["../build/injected_document_start.ts"],"names":[],"mappings":"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","sourcesContent":["function listenInContentScript(conectionName: string | undefined) {\r\n\t/**\r\n\t * this script executed within the context of the active tab when the user clicks the extension bar button\r\n\t * this script serves as a _very thin_ proxy between the page scripts (dapp) and the extension, simply forwarding messages between the two\r\n\t*/\r\n\t// the content script is a very thin proxy between the background script and the page script\r\n\r\n\tconst dec2hex = (dec: number) => dec.toString(16).padStart(2, '0')\r\n\r\n\tfunction generateId (len: number) {\r\n\t\tconst arr = new Uint8Array((len || 40) / 2)\r\n\t\tglobalThis.crypto.getRandomValues(arr)\r\n\t\treturn `0x${ Array.from(arr, dec2hex).join('') }`\r\n\t}\r\n\tconst connectionNameNotUndefined = conectionName === undefined ? generateId(40) : conectionName\r\n\r\n\tconst extensionPort = browser.runtime.connect({ name: connectionNameNotUndefined })\r\n\r\n\t// forward all message events to the background script, which will then filter and process them\r\n\tconst listener = (messageEvent: MessageEvent<any>) => {\r\n\t\ttry {\r\n\t\t\t// we only want the data element, if it exists, and postMessage will fail if it can't clone the object fully (and it cannot clone a MessageEvent)\r\n\t\t\tif (!('data' in messageEvent)) return\r\n\t\t\textensionPort.postMessage({ data: messageEvent.data })\r\n\t\t} catch (error) {\r\n\t\t\t// CONSIDER: should we catch data clone error and then do `extensionPort.postMessage({data:JSON.parse(JSON.stringify(messageEvent.data))})`?\r\n\t\t\tif (error instanceof Error) {\r\n\t\t\t\tif (error.message?.includes('Extension context invalidated.')) {\r\n\t\t\t\t\t// this error happens when the extension is refreshed and the page cannot reach The Interceptor anymore\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow error\r\n\t\t}\r\n\t}\r\n\tglobalThis.addEventListener('message', listener)\r\n\r\n\t// forward all messages we get from the background script to the window so the page script can filter and process them\r\n\textensionPort.onMessage.addListener(response => {\r\n\t\ttry {\r\n\t\t\tglobalThis.postMessage(response, '*')\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error(error)\r\n\t\t}\r\n\t})\r\n\r\n\textensionPort.onDisconnect.addListener(() => {\r\n\t\tglobalThis.removeEventListener('message', listener)\r\n\t\tlistenInContentScript(connectionNameNotUndefined)\r\n\t})\r\n}\r\n\r\nfunction injectScript(content: any) {\r\n\ttry {\r\n\t\tconst container = document.head || document.documentElement\r\n\t\tconst scriptTag = document.createElement('script')\r\n\t\tscriptTag.setAttribute('async', 'false')\r\n\t\tscriptTag.textContent = content\r\n\t\tcontainer.insertBefore(scriptTag, container.children[0])\r\n\t\tcontainer.removeChild(scriptTag)\r\n\t\tlistenInContentScript(undefined)\r\n\t} catch (error) {\r\n\t  \tconsole.error('Interceptor: Provider injection failed.', error)\r\n\t}\r\n}\r\n\r\ninjectScript(`\"use strict\";\nconst METAMASK_ERROR_USER_REJECTED_REQUEST = 4001;\nconst METAMASK_ERROR_CHAIN_NOT_ADDED_TO_METAMASK = 4902;\nclass InterceptorFuture {\n    promise;\n    resolveFunction;\n    rejectFunction;\n    constructor() {\n        let resolveFunction;\n        let rejectFunction;\n        this.promise = new Promise((resolve, reject) => {\n            resolveFunction = resolve;\n            rejectFunction = reject;\n        });\n        // the function passed to the Promise constructor is called before the constructor returns, so we can be sure the resolve and reject functions have been set by here even if the compiler can't verify\n        this.resolveFunction = resolveFunction;\n        this.rejectFunction = rejectFunction;\n    }\n    then = (onfulfilled, onrejected) => {\n        return this.promise.then(onfulfilled, onrejected);\n    };\n    resolve = (value) => {\n        this.resolveFunction(value);\n    };\n    reject = (reason) => {\n        this.rejectFunction(reason);\n    };\n}\nclass EthereumJsonRpcError extends Error {\n    code;\n    data;\n    constructor(code, message, data) {\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.name = this.constructor.name;\n    }\n}\nclass InterceptorMessageListener {\n    connected = false;\n    requestId = 0;\n    signerWindowEthereumRequest = undefined;\n    outstandingRequests = new Map();\n    onMessageCallBacks = new Set();\n    onConnectCallBacks = new Set();\n    onAccountsChangedCallBacks = new Set();\n    onDisconnectCallBacks = new Set();\n    onChainChangedCallBacks = new Set();\n    constructor() {\n        this.injectEthereumIntoWindow();\n    }\n    WindowEthereumIsConnected = () => this.connected;\n    sendMessageToBackgroundPage = async (messageMethodAndParams) => {\n        this.requestId++;\n        const pendingRequestId = this.requestId;\n        const future = new InterceptorFuture();\n        this.outstandingRequests.set(pendingRequestId, future);\n        try {\n            window.postMessage({\n                interceptorRequest: true,\n                options: {\n                    method: messageMethodAndParams.method,\n                    params: messageMethodAndParams.params,\n                },\n                usingInterceptorWithoutSigner: this.signerWindowEthereumRequest === undefined,\n                requestId: pendingRequestId,\n            }, '*');\n            return await future;\n        }\n        catch (error) {\n            throw error;\n        }\n        finally {\n            this.outstandingRequests.delete(pendingRequestId);\n        }\n    };\n    // sends messag to The Interceptor background page\n    WindowEthereumRequest = async (options) => {\n        try {\n            // make a message that the background script will catch and reply us. We'll wait until the background script replies to us and return only after that\n            return await this.sendMessageToBackgroundPage({ method: options.method, params: options.params });\n        }\n        catch (error) {\n            // if it is an Error, add context to it if context doesn't already exist\n            if (error instanceof Error) {\n                if (!('code' in error))\n                    error.code = -32603;\n                if (!('data' in error) || error.data === undefined || error.data === null)\n                    error.data = { request: options };\n                else if (!('request' in error.data))\n                    error.data.request = options;\n                throw error;\n            }\n            // if someone threw something besides an Error, wrap it up in an error\n            throw new EthereumJsonRpcError(-32603, \\`Unexpected thrown value.\\`, { error: error, request: options });\n        }\n    };\n    // ðŸ¤¬ Uniswap, among others, require \\`send\\` to be implemented even though it was never part of any final specification.\n    // To make matters worse, some versions of send will have a first parameter that is an object (like \\`request\\`) and others will have a first and second parameter.\n    // On top of all that, some applications have a mix of both!\n    WindowEthereumSend = async (method, params) => {\n        if (typeof method === 'object')\n            return await this.WindowEthereumRequest({ method: method.method, params: method.params });\n        return await this.WindowEthereumRequest({ method, params });\n    };\n    WindowEthereumSendAsync = async (payload, callback) => {\n        this.WindowEthereumRequest(payload)\n            .then(result => callback(null, { jsonrpc: '2.0', id: payload.id, result }))\n            // since \\`request(...)\\` only throws things shaped like \\`JsonRpcError\\`, we can rely on it having those properties.\n            .catch(error => callback({ jsonrpc: '2.0', id: payload.id, error: { code: error.code, message: error.message, data: { ...error.data, stack: error.stack } } }, null));\n    };\n    static exhaustivenessCheck = (_thing) => { };\n    WindowEthereumOn = (kind, callback) => {\n        if (window.ethereum === undefined)\n            throw new Error('window.ethereum is not defined');\n        switch (kind) {\n            case 'accountsChanged':\n                this.onAccountsChangedCallBacks.add(callback);\n                break;\n            case 'message':\n                this.onMessageCallBacks.add(callback);\n                break;\n            case 'connect':\n                this.onConnectCallBacks.add(callback);\n                break;\n            case 'close': //close is deprecated on eip-1193 by disconnect but its still used by dapps (MyEtherWallet)\n                this.onDisconnectCallBacks.add(callback);\n                break;\n            case 'disconnect':\n                this.onDisconnectCallBacks.add(callback);\n                break;\n            case 'chainChanged':\n                this.onChainChangedCallBacks.add(callback);\n                break;\n            default: InterceptorMessageListener.exhaustivenessCheck(kind);\n        }\n        return window.ethereum;\n    };\n    WindowEthereumRemoveListener = (kind, callback) => {\n        if (window.ethereum === undefined)\n            throw new Error('window.ethereum is not defined');\n        switch (kind) {\n            case 'accountsChanged':\n                this.onAccountsChangedCallBacks.delete(callback);\n                break;\n            case 'message':\n                this.onMessageCallBacks.delete(callback);\n                break;\n            case 'connect':\n                this.onConnectCallBacks.delete(callback);\n                break;\n            case 'close': //close is deprecated on eip-1193 by disconnect but its still used by dapps (MyEtherWallet)\n                this.onDisconnectCallBacks.delete(callback);\n                break;\n            case 'disconnect':\n                this.onDisconnectCallBacks.delete(callback);\n                break;\n            case 'chainChanged':\n                this.onChainChangedCallBacks.delete(callback);\n                break;\n            default: InterceptorMessageListener.exhaustivenessCheck(kind);\n        }\n        return window.ethereum;\n    };\n    WindowEthereumEnable = async () => this.WindowEthereumRequest({ method: 'eth_requestAccounts' });\n    requestAccountsFromSigner = async () => {\n        if (this.signerWindowEthereumRequest === undefined)\n            return;\n        const reply = await this.signerWindowEthereumRequest({ method: 'eth_requestAccounts', params: [] });\n        if (!Array.isArray(reply))\n            return;\n        return await this.sendMessageToBackgroundPage({ method: 'eth_accounts_reply', params: reply });\n    };\n    requestChainIdFromSigner = async () => {\n        if (this.signerWindowEthereumRequest === undefined)\n            return;\n        const reply = await this.signerWindowEthereumRequest({ method: 'eth_chainId', params: [] });\n        if (typeof reply !== 'string')\n            return;\n        return await this.sendMessageToBackgroundPage({ method: 'signer_chainChanged', params: [reply] });\n    };\n    static checkErrorForCode = (error) => {\n        if (typeof error !== 'object')\n            return false;\n        if (error === null)\n            return false;\n        if (!('code' in error))\n            return false;\n        if (typeof error.code !== 'number')\n            return false;\n        return true;\n    };\n    requestChangeChainFromSigner = async (chainId) => {\n        if (this.signerWindowEthereumRequest === undefined)\n            return;\n        try {\n            const reply = await this.signerWindowEthereumRequest({ method: 'wallet_switchEthereumChain', params: [{ 'chainId': chainId }] });\n            if (reply !== null)\n                return;\n            await this.sendMessageToBackgroundPage({ method: 'wallet_switchEthereumChain_reply', params: [{ accept: true, chainId: chainId }] });\n        }\n        catch (error) {\n            if (InterceptorMessageListener.checkErrorForCode(error) && (error.code === METAMASK_ERROR_USER_REJECTED_REQUEST || error.code === METAMASK_ERROR_CHAIN_NOT_ADDED_TO_METAMASK)) {\n                await this.sendMessageToBackgroundPage({ method: 'wallet_switchEthereumChain_reply', params: [{ accept: false, chainId: chainId }] });\n            }\n            throw error;\n        }\n    };\n    handleReplyRequest = async (replyRequest) => {\n        try {\n            if (replyRequest.subscription !== undefined) {\n                return this.onMessageCallBacks.forEach((f) => f({ type: 'eth_subscription', data: replyRequest.result }));\n            }\n            // inform callbacks\n            switch (replyRequest.options.method) {\n                case 'accountsChanged': return this.onAccountsChangedCallBacks.forEach((f) => f(replyRequest.result));\n                case 'connect': {\n                    this.connected = true;\n                    return this.onConnectCallBacks.forEach((f) => f({ chainId: replyRequest.result }));\n                }\n                case 'disconnect': {\n                    this.connected = false;\n                    const resultArray = replyRequest.result;\n                    return this.onDisconnectCallBacks.forEach((f) => f({ name: 'disconnect', ...resultArray }));\n                }\n                case 'chainChanged': return this.onChainChangedCallBacks.forEach((f) => f(replyRequest.result));\n                case 'request_signer_to_eth_requestAccounts': return await this.requestAccountsFromSigner();\n                case 'request_signer_to_wallet_switchEthereumChain': return await this.requestChangeChainFromSigner(replyRequest.result);\n                case 'request_signer_chainId': return await this.requestChainIdFromSigner();\n                default: break;\n            }\n        }\n        finally {\n            const pending = this.outstandingRequests.get(replyRequest.requestId);\n            if (pending === undefined)\n                return;\n            if (replyRequest.error !== undefined) {\n                return pending.reject(new EthereumJsonRpcError(replyRequest.error.code, replyRequest.error.message, { request: replyRequest.options }));\n            }\n            return pending.resolve(replyRequest.result);\n        }\n    };\n    onMessage = async (messageEvent) => {\n        if (typeof messageEvent !== 'object'\n            || messageEvent === null\n            || !('data' in messageEvent)\n            || typeof messageEvent.data !== 'object'\n            || messageEvent.data === null\n            || !('interceptorApproved' in messageEvent.data))\n            return;\n        if (!('ethereum' in window) || !window.ethereum)\n            throw new Error('window.ethereum missing');\n        if (!('options' in messageEvent.data && typeof messageEvent.data.options === 'object' && messageEvent.data.options !== null))\n            throw new Error('missing options field');\n        if (!('method' in messageEvent.data.options))\n            throw new Error('missing method field');\n        const forwardRequest = messageEvent.data; //use \"as\" here as we don't want to inject funtypes here\n        if (forwardRequest.error !== undefined) {\n            const pending = this.outstandingRequests.get(forwardRequest.requestId);\n            if (pending === undefined)\n                throw new EthereumJsonRpcError(forwardRequest.error.code, forwardRequest.error.message);\n            return pending.reject(new EthereumJsonRpcError(forwardRequest.error.code, forwardRequest.error.message, { request: forwardRequest.options }));\n        }\n        if (forwardRequest.result !== undefined)\n            return this.handleReplyRequest(forwardRequest);\n        try {\n            if (this.signerWindowEthereumRequest == undefined)\n                throw 'Interceptor is in wallet mode and should not forward to an external wallet';\n            const reply = await this.signerWindowEthereumRequest(forwardRequest.options);\n            this.outstandingRequests.get(forwardRequest.requestId).resolve(reply);\n        }\n        catch (error) {\n            // if it is an Error, add context to it if context doesn't already exist\n            console.log(error);\n            console.log(messageEvent);\n            if (error instanceof Error) {\n                if (!('code' in error))\n                    error.code = -32603;\n                if (!('data' in error) || error.data === undefined || error.data === null)\n                    error.data = { request: forwardRequest.options };\n                else if (!('request' in error.data))\n                    error.data.request = forwardRequest.options;\n                return this.outstandingRequests.get(forwardRequest.requestId).reject(error);\n            }\n            if (error.code !== undefined && error.message !== undefined) {\n                return this.outstandingRequests.get(forwardRequest.requestId).reject(new EthereumJsonRpcError(error.code, error.message, { request: forwardRequest.options }));\n            }\n            // if the signer we are connected threw something besides an Error, wrap it up in an error\n            this.outstandingRequests.get(forwardRequest.requestId).reject(new EthereumJsonRpcError(-32603, \\`Unexpected thrown value.\\`, { error: error, request: forwardRequest.options }));\n        }\n    };\n    sendConnectedMessage = async (signerName) => {\n        return await this.sendMessageToBackgroundPage({ method: 'connected_to_signer', params: [signerName] });\n    };\n    unsupportedMethods = (windowEthereum) => {\n        const unsupportedError = (method) => {\n            return console.error(\\`The application tried to call a deprecated or non-standard method: \"\\${method}\". Please contact the application developer to fix this issue.\\`);\n        };\n        return {\n            once: (() => { return unsupportedError('window.ethereum.once()'); }).bind(windowEthereum),\n            prependListener: (() => { return unsupportedError('window.ethereum.prependListener()'); }).bind(windowEthereum),\n            prependOnceListener: (() => { return unsupportedError('window.ethereum.prependOnceListener()'); }).bind(windowEthereum),\n            _metamask: {\n                isUnlocked: (async () => {\n                    unsupportedError('window.ethereum._metamask.isUnlocked()');\n                    return this.connected;\n                }),\n                requestBatch: async () => { return unsupportedError('window.ethereum._metamask.requestBatch()'); }\n            }\n        };\n    };\n    injectEthereumIntoWindow = () => {\n        if (!('ethereum' in window) || !window.ethereum) {\n            // no existing signer found\n            window.ethereum = {\n                isConnected: this.WindowEthereumIsConnected.bind(window.ethereum),\n                request: this.WindowEthereumRequest.bind(window.ethereum),\n                send: this.WindowEthereumSend.bind(window.ethereum),\n                sendAsync: this.WindowEthereumSendAsync.bind(window.ethereum),\n                on: this.WindowEthereumOn.bind(window.ethereum),\n                removeListener: this.WindowEthereumRemoveListener.bind(window.ethereum),\n                enable: this.WindowEthereumEnable.bind(window.ethereum),\n                ...this.unsupportedMethods(window.ethereum),\n            };\n            this.connected = true;\n            this.sendConnectedMessage('NoSigner');\n            return;\n        }\n        // subscribe for signers events\n        window.ethereum.on('accountsChanged', (accounts) => {\n            this.WindowEthereumRequest({ method: 'eth_accounts_reply', params: accounts });\n        });\n        window.ethereum.on('connect', (_connectInfo) => {\n        });\n        window.ethereum.on('disconnect', (_error) => {\n            this.WindowEthereumRequest({ method: 'eth_accounts_reply', params: [] });\n        });\n        window.ethereum.on('chainChanged', (chainId) => {\n            this.WindowEthereumRequest({ method: 'signer_chainChanged', params: [chainId] });\n        });\n        this.connected = window.ethereum.isConnected();\n        this.signerWindowEthereumRequest = window.ethereum.request.bind(window.ethereum); // store the request object to signer\n        if (window.ethereum.isBraveWallet) {\n            window.ethereum = {\n                isConnected: this.WindowEthereumIsConnected.bind(window.ethereum),\n                request: this.WindowEthereumRequest.bind(window.ethereum),\n                send: this.WindowEthereumSend.bind(window.ethereum),\n                sendAsync: this.WindowEthereumSendAsync.bind(window.ethereum),\n                on: this.WindowEthereumOn.bind(window.ethereum),\n                removeListener: this.WindowEthereumRemoveListener.bind(window.ethereum),\n                enable: this.WindowEthereumEnable.bind(window.ethereum),\n                ...this.unsupportedMethods(window.ethereum),\n            };\n            this.sendConnectedMessage('Brave');\n            return;\n        }\n        // we cannot inject window.ethereum alone here as it seems like window.ethereum is cached (maybe ethers.js does that?)\n        Object.assign(window.ethereum, {\n            isConnected: this.WindowEthereumIsConnected.bind(window.ethereum),\n            request: this.WindowEthereumRequest.bind(window.ethereum),\n            send: this.WindowEthereumSend.bind(window.ethereum),\n            sendAsync: this.WindowEthereumSendAsync.bind(window.ethereum),\n            on: this.WindowEthereumOn.bind(window.ethereum),\n            removeListener: this.WindowEthereumRemoveListener.bind(window.ethereum),\n            enable: this.WindowEthereumEnable.bind(window.ethereum),\n            ...this.unsupportedMethods(window.ethereum),\n        });\n        this.sendConnectedMessage(window.ethereum.isMetaMask ? 'MetaMask' : 'NotRecognizedSigner');\n    };\n}\nfunction injectInterceptor() {\n    const interceptorMessageListener = new InterceptorMessageListener();\n    window.addEventListener('message', interceptorMessageListener.onMessage);\n    // listen if Metamask injects their payload, and if so, reinject Interceptor\n    const interceptorCapturedDispatcher = window.dispatchEvent;\n    window.dispatchEvent = (event) => {\n        interceptorCapturedDispatcher(event);\n        if (!(typeof event === 'object' && event !== null && 'type' in event && typeof event.type === 'string'))\n            return;\n        if (event.type !== 'ethereum#initialized')\n            return;\n        interceptorMessageListener.injectEthereumIntoWindow();\n        window.dispatchEvent = interceptorCapturedDispatcher;\n    };\n}\ninjectInterceptor();\n`)\r\n"]}